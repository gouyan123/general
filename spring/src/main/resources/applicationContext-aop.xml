<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xmlns:context="http://www.springframework.org/schema/context"
       xsi:schemaLocation="http://www.springframework.org/schema/beans
      http://www.springframework.org/schema/beans/spring-beans.xsd
      http://www.springframework.org/schema/context
      http://www.springframework.org/schema/context/spring-context.xsd">

    <!--注册目标对象-->
    <bean id="someService" class="com.bjpowernode.aop.introduction.SomeServiceImpl"/>

    <!--注册切面：通知-->
    <bean id="myMethodBeforeAdvice" class="com.bjpowernode.aop.introduction.MyMethodBeforeAdvice"/>
    <bean id="myAfterReturningAdvice" class="com.bjpowernode.aop.introduction.MyAfterReturningAdvice"/>
    <bean id="myInterceptorAdvice" class="com.bjpowernode.aop.introduction.MyMethodInterceptor"/>
    <bean id="myThrowsAdvice" class="com.bjpowernode.aop.introduction.MyThrowsAdvice"/>

    <!--注册切面：顾问-->
    <!--<bean id="myAdvisor" class="org.springframework.aop.support.NameMatchMethodPointcutAdvisor">
        &lt;!&ndash;指定通知：顾问是对通知的封装，因此里面含有通知&ndash&ndash;&gt;
        <property name="advice" ref="myAfterReturningAdvice"/>
        &lt;!&ndash;指定切入点，即指定方法织入通知切面&ndash;&gt;
        <property name="mappedNames">
            <array>
                <value>doFirst</value>
                <value>doThird</value>
            </array>
        </property>
    </bean>-->

    <!--注册切面：正则表达式顾问-->

    <bean id="myAdvisor" class="org.springframework.aop.support.RegexpMethodPointcutAdvisor">
        <!--指定通知：顾问是对通知的封装，因此里面含有通知-->
        <property name="" ref="myAfterReturningAdvice"/>
        <!--指定切入点，即指定方法织入通知切面&ndash-->
        <property name="patterns"><!--正则表达式：. 任意字符；* 前一个字符出现0次或多次；+ 前一个字符出现1次或多次 -->
            <array>               <!--正则表达式匹配的是全限定性方法名-->
                <value>.*doFirst</value><!-- .* 代表 包名 + 类名 -->
                <value>.*doThird</value>
            </array>
        </property>
    </bean>


    <!--注册代理工厂bean，生成代理对象-->
    <!--代理生成器缺点：①一个代理对象只能代理一个bean；②客户端使用的是代理类bean，而不是目标类id-->
    <!--<bean id="serviceProxy" class="org.springframework.aop.framework.ProxyFactoryBean">
        <property name="target" ref="someService"/>
        &lt;!&ndash;<property name="interceptorNames" value="myAdvice"/>&ndash;&gt;&lt;!&ndash;拦截器名称&ndash;&gt;
        <property name="interceptorNames">&lt;!&ndash;多个方法织入多个切面&ndash;&gt;
            <array>
                <value>myAdvisor</value>  &lt;!&ndash;切面&ndash;&gt;
                &lt;!&ndash;<value>myMethodBeforeAdvice</value>&ndash;&gt;
                &lt;!&ndash;<value>myAfterReturningAdvice</value>&ndash;&gt;  &lt;!&ndash;切面&ndash;&gt;
                &lt;!&ndash;<value>myInterceptorAdvice</value>&ndash;&gt;  &lt;!&ndash;切面&ndash;&gt;
                &lt;!&ndash;<value>myThrowsAdvice</value>&ndash;&gt;  &lt;!&ndash;切面&ndash;&gt;
            </array>
        </property>
    </bean>-->

    <!--注册自动代理生成器-->
    <!--原理：bean后处理器，在bean初始化前后，将织入-->
    <!--存在 3 个问题：①不能选择目标对象；②不能选择切面类型，切面只能是advisor；③所有advisor将被作为切面-->
    <!--<bean class="org.springframework.aop.framework.autoproxy.DefaultAdvisorAutoProxyCreator"/>-->

    <!--注册BeanName自动代理生成器-->
    <bean class="org.springframework.aop.framework.autoproxy.BeanNameAutoProxyCreator">
        <property name="beanNames" value="someService"/>
        <property name="interceptorNames" value="myAdvisor"/>
    </bean>
</beans>