多态条件：①继承；②重写；③父类引用指向子类对象；
创建 Animal 类，创建 Cat 类继承 Animal，创建 Dog 类继承 Animal类，并重写 voice()方法；

内存分析（多态内存分析.png）：
1、将 Animal.class 字节码文件加载到方法区，得到Animal类的运行时数据结构，并在堆内存中生成Animal类的反射
类对象，通过该反射类对象获得Animal类运行时数据；链接；初始化；使用；销毁；
2、Cat类 加载 链接 初始化 使用 销毁同上；
3、Animal类的main方法入栈形成main栈桢；main栈桢中定义Animal类型变量a，并Cat()方法入栈形成栈桢，在堆
内存中创建Cat类对象，并将地址值赋给 a；

*****************************************************************************************
继承原理：
java内部，通过隐式的组合来实现继承，即子类对象中会保存一个实例对象的引用super，该引用指向其父类。在实际
的方法调用时，java会先在当前类的对象中寻找名称相同的方法，如果没有，就到super引用的父类对象中去寻找该方
法，所以，若在子类中存在和 父类方法的签名和返回值类型完全相同的方法（重写）的话，java就会直接调用该对象的
方法而不用去父类去寻找调用方法了。而且在子类对象中，可以直接通过super来调用父类对象中的方法。
C类 → B类 → A类：C类继承B类，B类继承A类，new C()时，先调用A类构造方法再调用B类构造方法再调用C类构造方
法，但是A类和B类中，this都是指向 C类对象；同理，new B()时，先调用A类构造方法再调用B类构造方法，但是A类
中this指向 B 类对象；new A()时，调用A类构造方法，A类中 this 指向 A类对象；可以参考继承内存分析图；
总结：new 子类()时，会先调用父类构造方法，但是父类中 this 指向的却是子类；代码参考 Father Son GrandSon
类；new 谁，this指向谁；
******************************************************************************************

*****************************************************************************************
继承：小圈大圈图 + 大圈子类构造方法默认调用小圈父类无参构造super()，除非它里面调用大圈父类有参构造
super(参数)；
子类持有 父类对象引用super 为成员变量；
调用大圈子类成员变量(son.name)和方法(son.setName())时，有则直接调用，没有则去小圈父类super中查找，如果
小圈父类有该成员变量或方法，又没有使用private修饰，则可以直接调用，否则不能调用；
小圈父类中private修饰的方法不能被大圈子类所继承；
*****************************************************************************************

