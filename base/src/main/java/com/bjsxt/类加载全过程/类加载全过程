类加载机制：
类加载器将class文件 ①加载 到方法区中，并对内存中这些数据进行 ②链接，③初始化，最终形成JVM可以直接使用的
Java类型的过程；
①加载：
将class文件字节码内容加载到方法区中，并将静态数据转换成方法区中的运行时数据结构，在堆内存中生成这个类的反射类
对象，作为方法区该类数据的访问入口。
②链接：
将Java类的二进制代码合并到JVM的运行状态之中的过程；
a、验证：确定加载的类信息符合JVM规范，没有安全方面的问题；
b、准备：正式为类变量（static变量）分配内存并设置类变量初始值的阶段，这些内存都将在方法区中进行分配；
c、解析：虚拟机常量池内的符号引用替换为直接引用的过程；解释：写好一个类，里面很多常量，例如，类名，字符串
常量，数字常量；加载到Jvm中的每个类都有一个常量池，存放类的常量；
定义类 Demo01，其中，类名 Demo01，"aaa"，323432，String，int，= 等都是常量；
public class Demo01 {
    public static void main(String[] args) {
        String str = "aaa";
        int a = 323432;
    }
}
③初始化：
a、初始化阶段是执行类构造器<clint>()方法的过程。类构造器<clint>()是由编译器自动收集类中的所有类变量的
赋值动作和静态语句块{static块}中的语句合并产生的；
b、当初始化一个类的时候，如果其父类还没有进行初始化，则先将父类初始化；
c、虚拟机会保证一个类的<clint>()方法在多线程环境中被正确加锁和同步；
d、当访问一个Java类的静态域时，只有真正声明这个域的类才会被初始化；
例如，类中定义成员变量 static a = 3;在 ②链接阶段给类变量a分配内存空间并赋初值 a = 0;在 ③初始化阶段
才给类变量赋值 a = 3;

Demo01类文件里面创建 A 类
class A {
    public static int width = 100;
    static {
        System.out.println("静态初始化类A");
        width = 300;
    }
    public A(){ System.out.println("创建A类对象");}
}
Demo01类中创建A类对象a：
public class Demo01 {
    public static void main(String[] args) {
        /*要使用一个类，必须先 加载 链接(给静态资源分配空间) 初始化(给静态变量赋值并执行静态块) 使用 销毁*/
        A a = new A();
    }
}
运行结果：
静态初始化类A
创建A类对象
300

类加载过程：见图片 类加载全过程.png
①  加载类Demo01全过程：
a、 加载：将Demo01类的class字节码加载到方法区，得到Demo01类的运行时数据结构，即类代码，然后在堆内存中生
成该类反射类对象，通过反射类对象，可以动态获得类Demo01运行时数据结构；
b、 链接：静态变量分配空间并赋初始值(a=0,str=null)，常量池中符号引用换为直接引用(23,"abc")
c、 初始化：static变量初始化(a=23,str="abc")，static{}块执行；
②  main方法入栈形成main方法栈桢；栈中产生局部变量a = null，局部变量都存在栈中；new A()调用A类构造
方法（public A()方法入栈，形成A栈桢），按照方法区类的代码创建A类对象（类对象不包括static定义内容），
给地址a赋值；