****************************************************************************************
zookeeper使用要点：zk服务器中 创建根节点，在根节点下面创建瞬时序列节点，zk服务器中瞬时序列节点消失，代
表创建这个瞬时序列节点的节点宕机，zk服务器中任何节点的变化，都会调用zk客户端的监听方法，进行相应处理；
****************************************************************************************
引入 zookeeper 包
<dependency>
    <groupId>org.apache.zookeeper</groupId>
    <artifactId>zookeeper</artifactId>
    <version>3.4.12</version>
    <type>pom</type>
</dependency>
创建 cn.mldn.zookeeper.ZooKeeperClient 类，连接 Zookeeper 服务端
public class ZookeeperClient {
    public static void main(String[] args) throws Exception {
        /**连接地址，多个连接地址使用 , 分隔，体现面向分布式*/
        String connectStr = "47.100.49.95:2181,101.132.109.12:2181";
        /**连接超时时间*/
        int sessionTimeout = 2000;
        /**创建客户端连接对象 zooKeeper，客户端都是通过 客户端连接对象 操作服务端*/
        ZooKeeper zooKeeper = new ZooKeeper(connectStr, sessionTimeout, new Watcher() {
            @Override
            public void process(WatchedEvent watchedEvent) {
                System.out.println("path = " + watchedEvent.getPath() +
                                        " type = " + watchedEvent.getType() + " state = " + watchedEvent.getState());
            }
        });
        /**获取根节点 / 下面的所有子节点*/
        List<String> children = zooKeeper.getChildren("/",false);
        for (String child : children){
            System.out.println("child = " + child);
        }
    }
}
运行结果：
path = null type = None state = SyncConnected
child = mldndata
child = curator
child = mldn-servers
child = zookeeper
child = dubbo
child = LOCKS
child = mldn-lock
child = event
child = transaction

---------------------------------创建节点------------------------------------------------
节点分类：
持久节点：创建持久节点后，客户端断开连接后，服务端保存该节点；
瞬时节点：创建瞬时节点后，客户端断开连接后，服务端不保存该节点；
持久序列化节点：节点路径 = 节点名称 + 编号；节点编号顺序增长；
瞬时序列化解的：节点路径 = 节点名称 + 编号；节点编号顺序增长；
瞬时节点，瞬时序列节点是 ZooKeeper 的主要特点；

ZooKeeperClient类中创建 GROUPNODE，SUBNODE 成员变量，保存 跟节点路径，子节点路径；
private static final String GROUPNODE = "/mldndata";
private static final String SUBNODE = GROUPNODE + "/bigdata";
创建 永久父节点，瞬时子节点 代码如下：
public class ZookeeperClient {
    /**根节点路径*/
    private static final String GROUPNODE = "/mldndata";
    /**子节点路径*/
    private static final String SUBNODE = GROUPNODE + "/bigdata";
    public static void main(String[] args) throws Exception {

        /**连接地址，多个连接地址使用 , 分隔，体现面向分布式*/
        String connectStr = "47.100.49.95:2181,101.132.109.12:2181";
        /**连接超时时间*/
        int sessionTimeout = 2000;
        /**创建客户端连接对象 zooKeeper，客户端都是通过 客户端连接对象 操作服务端*/
        ZooKeeper zooKeeper = new ZooKeeper(connectStr, sessionTimeout, new Watcher() {
            @Override
            public void process(WatchedEvent watchedEvent) {
                System.out.println("path = " + watchedEvent.getPath() +
                        " type = " + watchedEvent.getType() + " state = " + watchedEvent.getState());
            }
        });
        /**创建父节点*/
        /*先判断节点是否存在，不存在，则创建*/
        if (zooKeeper.exists(GROUPNODE,false) == null){
            /**创建节点，各参数含义：节点路径；节点里面数据；安全认证模式；节点创建模式；*/
            /**此处创建的是 CreateMode.PERSISTENT 持久节点，即 客户端断开连接后，服务端保存该节点*/
            zooKeeper.create(GROUPNODE,"HelleData".getBytes(), ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);
        }
        /**创建子节点*/
        /*先判断节点是否存在，不存在，则创建*/
        if (zooKeeper.exists(SUBNODE,false) == null){
            /**创建节点，各参数含义：节点路径；节点里面数据；安全认证模式；节点创建模式；*/
            /**此处创建的是 CreateMode.EPHEMERAL 瞬时节点，即 客户端断开连接后，服务端不保存该节点*/
            zooKeeper.create(SUBNODE,"HelleSub".getBytes(), ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL);
        }

        /**获取根节点 / 下面的所有子节点*/
        List<String> children = zooKeeper.getChildren("/",false);
        for (String child : children){
            System.out.println("child = " + child);
        }
        /*Thread.sleep(Long.MAX_VALUE);*/
        /**释放连接*/
        zooKeeper.close();
    }
}

创建 永久父节点，瞬时序列子节点 代码如下：
public class ZookeeperClient {
    /**根节点路径*/
    private static final String GROUPNODE = "/mldndata";
    /**子节点路径*/
    private static final String SUBNODE = GROUPNODE + "/bigdata";
    public static void main(String[] args) throws Exception {

        /**连接地址，多个连接地址使用 , 分隔，体现面向分布式*/
        String connectStr = "47.100.49.95:2181,101.132.109.12:2181";
        /**连接超时时间*/
        int sessionTimeout = 2000;
        /**创建客户端连接对象 zooKeeper，客户端都是通过 客户端连接对象 操作服务端*/
        ZooKeeper zooKeeper = new ZooKeeper(connectStr, sessionTimeout, new Watcher() {
            @Override
            public void process(WatchedEvent watchedEvent) {
                System.out.println("path = " + watchedEvent.getPath() +
                        " type = " + watchedEvent.getType() + " state = " + watchedEvent.getState());
            }
        });
        /**创建父节点*/
        /*先判断节点是否存在，不存在，则创建*/
        if (zooKeeper.exists(GROUPNODE,false) == null){
            /**创建节点，各参数含义：节点路径；节点里面数据；安全认证模式；节点创建模式；*/
            /**此处创建的是 CreateMode.PERSISTENT 持久节点，即 客户端断开连接后，服务端保存该节点*/
            zooKeeper.create(GROUPNODE,"HelleData".getBytes(), ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);
        }
        /**创建子节点*/
        /*先判断节点是否存在，不存在，则创建*/
        for (int i=0;i<10;i++) {
            if (zooKeeper.exists(SUBNODE, false) == null) {
                /**创建节点，各参数含义：节点路径；节点里面数据；安全认证模式；节点创建模式；*/
                /**CreateMode.EPHEMERAL_SEQUENTIAL 瞬时序列化节点，即 客户端断开连接后，服务端不保存该节点*/
                String nodePath = zooKeeper.create(SUBNODE, "HelleSub".getBytes(), ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL_SEQUENTIAL);
                System.out.println("nodePath = " + nodePath);
            }
        }
        /**获取根节点 / 下面的所有子节点*/
        List<String> children = zooKeeper.getChildren("/",false);
        for (String child : children){
            System.out.println("child = " + child);
        }
        /*Thread.sleep(Long.MAX_VALUE);*/
        /**释放连接*/
        zooKeeper.close();
    }
}
瞬时序列节点路径如下：输入子路径为 /bigdata，系统会自动把他和编号连接起来；
nodePath = /mldndata/bigdata0000000002
nodePath = /mldndata/bigdata0000000003
nodePath = /mldndata/bigdata0000000004
nodePath = /mldndata/bigdata0000000005
nodePath = /mldndata/bigdata0000000006
nodePath = /mldndata/bigdata0000000007
nodePath = /mldndata/bigdata0000000008
nodePath = /mldndata/bigdata0000000009
nodePath = /mldndata/bigdata0000000010
nodePath = /mldndata/bigdata0000000011

---------------------------------节点数据操作---------------------------------------------
取得节点中的数据：在上述 main()方法中最下面，添加如下代码：
/**取得节点内容*/
if (zooKeeper.exists(GROUPNODE,false) != null){
    byte[] bytes = zooKeeper.getData(GROUPNODE,false,new Stat());
    String data = new String(bytes);
    System.out.println("data = " + data);
}
修改节点中的数据：在上述 main()方法中最下面，添加如下代码：
/**修改节点数据*/
/*存在该节点，就改该节点里面数据*/
if (zooKeeper.exists(GROUPNODE,false) != null){
    /*path：节点路径；watch：是否进行监听；version：修改哪个版本的数据 -1代表当前版本；stat：版本信息；*/
    Stat stat = zooKeeper.setData(GROUPNODE,"HelloGROUP".getBytes(),-1);
    System.out.println("stat = " + JSON.toJSONString(stat));
}
---------------------------------数据监听-------------------------------------------------
ZooKeeper数据监听：每次节点数据变化，都会触发监听器，用户需要根据触发的形式进行相应处理；
创建 ZooKeeperWatcher，对 根节点GROUPNODE及其子节点 进行监听；
public class ZooKeeperWatcher {
    /**根节点路径*/
    private static final String GROUPNODE = "/mldndata";
    /**子节点路径*/
    private static final String SUBNODE = GROUPNODE + "/bigdata";
    private static ZooKeeper zooKeeper;
    public static void main(String[] args) throws Exception {
        /**连接地址，多个连接地址使用 , 分隔，体现面向分布式*/
        String connectStr = "47.100.49.95:2181,101.132.109.12:2181";
        /**连接超时时间*/
        int sessionTimeout = 2000;
        /**创建客户端连接对象 zooKeeper，客户端都是通过 客户端连接对象 操作服务端*/
        /**ZooKeeper类中包含 Watcher 类对象，当监听节点状态发生变化时，ZooKeeper里面的方法可以调用
         *  Watcher 类的 process()方法*/
        zooKeeper = new ZooKeeper(connectStr, sessionTimeout, new Watcher() {
            @Override
            public void process(WatchedEvent watchedEvent) {
                System.out.println("path = " + watchedEvent.getPath() +
                        " type = " + watchedEvent.getType() + " state = " + watchedEvent.getState());
                try {
                    /**exists()方法会启动线程死循环检查GROUPNODE节点，当节点发生变化时，线程调用监听器
                     * 监听方法watcher.process()方法；*/
                    zooKeeper.exists(GROUPNODE,true);
                    /**对根节点GROUPNODE的所有子节点进行监听*/
                    /**getChildren()方法会启动线程死循环检查GROUPNODE节点的子节点，当子节点发生变化时
                     * ，线程调用监听器监听方法 watcher.process()方法；*/
                    zooKeeper.getChildren(GROUPNODE,true);
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
        });
        /**对 GROUPNODE 根节点进行监听，当GROUPNODE节点状态变化时，exists()方法里面调用 watcher.process()*/
        zooKeeper.exists(GROUPNODE,true);
        /**对根节点GROUPNODE的所有子节点进行监听，当子节点状态变化时，getChildren()方法里面调用
         * watcher.process()*/
        zooKeeper.getChildren(GROUPNODE,true);
        Thread.sleep(Long.MAX_VALUE);
        /**释放连接*/
        zooKeeper.close();
    }
}

---------------------------------服务器动态列表实现----------------------------------------
在集群环境开发中一定会有多台服务器出现，那么每一台服务器的信息我都希望可以进行动态监控，就是说假设有三台
服务器 a，b，c 想知道每台主机是否存在，这种情况使用ZooKeeper来实现；
如果要想对多台服务器本身进行监听；
要想实现本类程序，一定要在每一台服务器上都去部署一个ZooKeeper的运行项目（需要有一个ZooKeeper进程存在）；

原理：每个服务器上都要安装zookeeper服务器，多个服务器形成集群；每个服务器里面都有 2 个java程序：
①java程序-生成一个子节点：在zookeeper服务器上面创建 持久根节点/mldn-servers及瞬时子节点/mldn-servers/server-000000x，
如果该java程序与zookeepe服务器断开连接，其创建的瞬时子节点将在zookeeper上面消失，因此如果该服务器宕机
，那么这个服务器里面的java程序就会与zookeeper断开连接，zookeeper服务器中子节点将消失；
②java程序-获取所有子节点：获取zookeeper服务器中 根节点/mldn-servers 下面的所有子节点，即获得服务器动态列表；
注意：每个服务器上面都会安装 zookeeper服务器，这些zookeeper配置集群后，数据是同步的；

zookeeper不可以监听子节点数据，但是可以监听子节点变化，因此，所有服务器的节点信息都保存在 /mldn-servers
跟节点下，所有java程序(创建根节点/mldn-servers及临时节点/mldn-servers/server-000000x)创建的节点都
属于瞬时节点(a服务器上java程序创建的临时节点就代表这个a服务器)，按照如下方式排列：
/mldn-servers
    |-/mldn-servers/server-0000000;
    |-/mldn-servers/server-0000001;
    |-/mldn-servers/server-0000002;
    ...

2.2、开发服务器端程序
服务器端的程序主要是指部署在各个服务主机上运行的java程序，该程序的主要功能是向ZooKeeper里面发送临时节点
数据；
public class ServerListener {
    /**连接地址，多个连接地址使用 , 分隔，体现面向分布式*/
    private static final String connectStr = "47.100.49.95:2181,101.132.109.12:2181";
    /**连接超时时间*/
    private static final int sessionTimeout = 2000;
    /**根节点路径*/
    private static final String GROUPNODE = "/mldn-servers";
    /**子节点路径，序列节点会在 /server- 后面加编号*/
    private static final String SUBNODE = GROUPNODE + "/server-";
    private ZooKeeper zooKeeper;
    /**接收服务器名称，连接到zookeeper服务端并创建 持久化根节点/mldn-servers及 瞬时序列化子节点
     * /mldn-servers/server-编号，*/
    public ServerListener(String serverName) throws Exception {
        /*连接服务器，并创建 根节点，及下面子节点*/
        this.connectZooKeeperServer(serverName);
        this.handle();
    }

    public  void connectZooKeeperServer(String serverName) throws Exception {
        /**创建客户端连接对象 zooKeeper，客户端都是通过 客户端连接对象 操作服务端*/
        /**ZooKeeper类中包含 Watcher 类对象，当监听节点状态发生变化时，ZooKeeper里面的方法可以调用
         *  Watcher 类的 process()方法*/
        this.zooKeeper = new ZooKeeper(connectStr, sessionTimeout, new Watcher() {
            @Override
            public void process(WatchedEvent watchedEvent) {

            }
        });
        /**不存在 持久化根节点 /mldn-servers 则创建*/
        if (this.zooKeeper.exists(GROUPNODE,false) == null){
            this.zooKeeper.create(GROUPNODE,"ServerList".getBytes(), ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);
        }
        /**不存在 瞬时序列化子节点 /mldn-servers/server-编号 则创建*/
        if (this.zooKeeper.exists(SUBNODE,false) == null){
            /**serverName为服务器名称，java程序获得 根节点/mldn-servers 下面的所有子节点后，获得
             * 该serverName 的列表*/
            this.zooKeeper.create(SUBNODE,serverName.getBytes(), ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL_SEQUENTIAL);
        }
    }
    public void handle() throws InterruptedException {
        /*
        * 业务处理
        * */
        Thread.sleep(Long.MAX_VALUE);
        /*关闭连接*/
        this.zooKeeper.close();
    }
}
程序最终一定要放到服务器中去执行，所以需要一个启动的处理方法，cn.mldn.main 包中创建 StartServerMain
public class StartServerMain {
    /**通过args传服务器名 serverName*/
    public static void main(String[] args) {
        if (args.length == 0){
            System.out.println("Please enter ServerName");
            /**退出系统*/
            System.exit(1);
        }
        try {
            /**启动 ServerListener 连接zookeeper，创建节点*/
            new ServerListener(args[0]);
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}
2.3、服务器端程序部署：
将该项目打 可执行jar包 ，然后部署到服务器上面；
2.4、开发客户端程序：
客户端java程序的主要功能是通过ZooKeeper获得所有服务器信息，即根节点 /mldn-servers 下面的所有瞬时子节点
/mldn-servers/server-编号，创建 ServerListClientListener 类
public class ServerListClientListener {
    /**连接地址，多个连接地址使用 , 分隔，体现面向分布式*/
    private static final String connectStr = "47.100.49.95:2181,101.132.109.12:2181";
    /**连接超时时间*/
    private static final int sessionTimeout = 2000;
    /**根节点路径*/
    private static final String GROUPNODE = "/mldn-servers";
    /**子节点路径，序列节点会在 /server- 后面加编号*/
    private static final String SUBNODE = GROUPNODE + "/server-";
    private ZooKeeper zooKeeper;

    public ServerListClientListener() throws Exception {
        /*连接zookeeper服务端，获得 zookeeper客户端连接对象，可以操作zookeeper服务端*/
        this.connectZooKeeperServer();
        Set<String> servers = this.getServerList();
        System.out.println(JSON.toJSONString(servers,true));
        Thread.sleep(Long.MAX_VALUE);
    }

    private void connectZooKeeperServer() throws Exception {
        /**创建客户端连接对象，通过客户端连接对象操作服务端*/
        this.zooKeeper = new ZooKeeper(connectStr, sessionTimeout, new Watcher() {
            @Override
            public void process(WatchedEvent watchedEvent) {
                if (watchedEvent.getPath() != null){
                    /*子节点发生变化*/
                    if (watchedEvent.getType() == Event.EventType.NodeChildrenChanged){
                        try {
                            Set<String> servers = ServerListClientListener.this.getServerList();
                            System.out.println(JSON.toJSONString(servers));
                        } catch (Exception e) {
                            e.printStackTrace();
                        }
                    }
                }
            }
        });
        /*如果没有根节点 /mldn-servers 则创建*/
        if (this.zooKeeper.exists(GROUPNODE,false) == null){
            this.zooKeeper.create(GROUPNODE,"ServerList".getBytes(), ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);
        }
    }

    public Set<String> getServerList() throws Exception {
        Set<String> servers = new LinkedHashSet<String>();
        /**获取根节点 GROUPNODE 节点下面的所有子节点；true监听：开启多线程死循环检查跟节点下面的子节点，当
         * 子节点变化时，线程调用监听器监听方法 watcher.process(event)*/
        List<String> children = this.zooKeeper.getChildren(GROUPNODE,true);
        /**child为 server-00x，即子节点相对路径*/
        for (String child : children){
            /*子节点全路径*/
            String path = GROUPNODE + "/" + child;
            /**获取子节点里面的数据*/
            byte[] bytes = this.zooKeeper.getData(path,false,new Stat());
            String serverName = new String(bytes);
            servers.add(serverName);
        }
        return servers;
    }

    public static void main(String[] args) {
        try {
            new ServerListClientListener();
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}

测试：
开启 2 个 ServerListener，服务器名分别为 zcf gouyan；
开启 ServerListClientListener，返回 服务器列表 ["zcf","gouyan"]；关闭zcf服务器进程，
ServerListClientListener 自动返回 服务器列表 ["gouyan"]

---------------------------------分布式锁-------------------------------------------------

在java中对于同一个jvm而言，jdk已经提供了lock和同步等。但是在分布式情况下，往往存在多个进程对一些资源产
生竞争关系，而这些进程往往在不同的机器上，这个时候jdk中提供的已经不能满足。
分布式锁：多台主机同时操作同一资源时，需要分布式锁，保证多台主机能够按照指定顺序操作该同一资源；

当很多主机需要访问共享资源时，我们可以通过zk来实现分布式锁。主要步骤是：
1、创建一个永久性根节点，作锁的根目录；
2、当要获取一个锁时，在锁目录下创建一个瞬时序列化节点，作为当前节点；
3、检查锁目录的子节点是否有序列比当前节点小，若有则监听比它小的上一个节点的删除事件，当前节点处于等待状态；
4、当监听器被前一个节点删除事件触发时，当前节点等待结束，获得锁；

*****************************************************************************************
原理：永久根节点下面的瞬时序列节点特性(客户端断开连接，服务端该瞬时序列节点消失) + zookeeper监控 +
lock机制(lock.lock()原理：一部分线程进入 lock()方法，能走出来，即方法执行完毕，继续执行 lock.lock()
后面的语句，即获得锁；一部分线程进入 run()方法，处于等待状态，走不出来，不能执行 lock.lock()后面的语句
，即没有获得锁)；
*****************************************************************************************
实例：多个进程要获取订单编号orderCodeGenerator.getOrderCode()，创建订单orderServiceImpl.createOrder()
定义 cn.mldn.lock.OrderCodeGenerator 类，将当前时间转换成编号，提供订单编号
public class OrderCodeGenerator {
	// 按照“年-月-日-小时-分钟-秒-自增长序列”的规则生成订单编号
	public String getOrderCode() {
		Date now = new Date();
		SimpleDateFormat sdf = new SimpleDateFormat("yyyyMMddHHmmss");
		return sdf.format(now);
	}
}
定义 cn.mldn.lock.OrderServiceImpl implements Runnable 类，模拟多线程调用 createOrder()方法，
创建订单，createOrder()方法中使用 lock.lock()，只有一个线程能走出 lock()方法继续执行，其他线程都等
待在 lock()方法中，等待到符合条件时即当前节点前一个节点被删除时监听方法调用latch.countDown()，lock()
方法中latch.await()等待结束，线程等待结束，继续运行 lock.lock()后面语句，即获得锁；
cn.mldn.lock.ImproveLock 根代码注解；
